
1. По контуру модельки идет хитбокс, выступающий генератором событий [[Коллизия с уроном и Дотами]]
2. Переменная isEnemy: bool, отвечающая за то, является ли объект врагом или связанным с врагом.
3. Обладает тегом. тег заполняется в зависимости, [[Игровой персонаж|игрок]] или [[Враги|враг]].
4. Находится в слое [[Слои|слое]] enemy
5. Осуществляет поворот со скоростью rotateSpeed
Переменные:
1. Все характеристики берутся из файла [[Улучшаемые характеристики]] (по условию type == true) как отдельные переменные.
2. actualHP -- int -- переменная актуального хп
3. Добавляется массив recievedDots -- object array -- массив полученных (как цель воздействия) ДОТов. 
4.   usableDotsArray -- Массив объектов Имеющихся ДОТов
5. shootingModifierFirstArray, shootingModifierSecondArray, shootingModifierThirdArray -- массивы String, содержащие в себе code модификаторов стрельбы.
6. whileFlyModifiersArray, onCollisionModifiersArray, whenDestroyModifiersArray -- массивы String кодов модификаторов полета пули.
7. isCanDie
8. точки стрельбы shotPointsArray = new List shotPoint
	    new ShotPoint { angle = 0f, dirction = vector3, isActive = true } 
   
**Методы:**
9. Стрельба осуществляется через **метод Стрельбы
10. Обладает методом [[Генерация выстрела| Генерации выстрела]]
11. Обладает методом [[Коллизия с уроном и Дотами]]
12. Обладает **Методом смерти**, переопределяемым для [[Игровой персонаж]]
13. метод [[Выпадение Дропа]]
14. **конструктор объектов наносимых дотов**
15. **конструктор объектов Полученных дотов**
16. **Метод добавления в массив ДОТов usableDotsArray**
17. **Метод заполнения recievedDots массива полученных ДОТов**
18. **метод Проверки уворота**
19. **Метод получения урона до брони**
20. **Метод получения урона**
21. **Метод обработки воздействия полученных ДОТов**
22. **Метод применения модификаторов стрельбы**
23. **Метод ближнего боя**
24. 1
25. Метод **Вампиризма**
26. **Метод нанесения урона ближнего боя**
27. **Метод изменения точек стрельбы**





Создать **конструктор объектов Полученных дотов**: 
	Примечание: Получает значения
	 [[Улучшаемые характеристики]] = improvableCharacteristicDictionary
	[[Справочник ДОТов]] = dotsDictionary
	Маппинг: improvableCharacteristicDictionary.code = dotsDictionary.code 
	1. Объект содержит: code, DotDmg, DotDur, type, affectedChar, count, tick
	2. Объект = значение, переданное в метод, в случае, если их не хватает, обогатить из справочников по маппингу:
		1. code = improvableCharacteristicDictionary.code
		2. affectedChar = dotsDictionary.affectedChar
		3. type = dotsDictionary.type,
		4. DotDmg =  dotsDictionary.baseDotDmg
		5. DotDur = dotsDictionary.baseDotDur
		6. affectedDamage = 0
		7. count = 1
		8. tick = 0;



**Метод Стрельбы**
	Принимает значения: 
	Запрашивает значение дамага, массива дотов, скорости атаки
	Стрелять можно если от последнего выстрела прошло 1/скорость атаки тиков.
		Если проверка пройдена, вызвать метод **Метод применения модификаторов стрельбы**
	


**Метод применения модификаторов стрельбы**
Принимает значения: 
 1. Взять значение точек стрельбы перебором по массиву shotPointsArray для каждого объекта shotPoint:
 2. Для каждой точки Взять значение shootingModifierSecondArray для каждого:
	 2. по code взять значение из [[Справочник модификаторов стрельбы]], определить type:
		 4. Если base, то Совершать только один выстрел
		 5. Если burst -- сформировать очередь из count количества выстрелов, с задержкой между ними 1/(count * atkSpeed) секунд. *Кулдаун будет отсчитываться от последнего выстрела в очереди*
 3. Для каждого выстрела: 
	 1. по code взять значение из [[Справочник модификаторов стрельбы]], определить type(Да, сейчас тут нет разницы, но я подозреваю, что она может быть, правда пока ХЭЗЭ какая):
		 1. Если base, то Создать один патрон [[Генерация выстрела]], Передав в него spread = (1 - accuracy из справочника) * 10, dmg, usableDotsArray, critChance, bulletflySpeed, bulletTimeAlive, whileFlyModifiersArray, onCollisionModifiersArray, whenDestroyModifiersArray, gameobjectId стреляющего
		 2. Если buckshot, то создать count патронов ([[Генерация выстрела]]), передавая в каждый spread = (1 - accuracy из справочника) * 10, dmg, usableDotsArray, critChance, bulletflySpeed, bulletTimeAlive, whileFlyModifiersArray, onCollisionModifiersArray, whenDestroyModifiersArray, gameobjectId, shotPointsArray.shotPoint.direction




**Метод ближнего боя**
Срабатывает при коллизии. Только в слоях, где находится игрок и Враги. 
1. Проверить тег того, с кем коллизия. Тег должен быть противоположен в дихотомии "Player" - "Enemy" И не содержать "Bullet". Если условия выполнены:
	1. **Метод нанесения урона ближнего боя**
	2. Ждать 1/atkSpeed, не давая вызвать **Метод нанесения урона ближнего боя**



**Метод добавления в массив ДОТов usableDotsArray**
	Принимает объект ДОТа
		1. Добавить Объект ДОТа в массив usableDotsArray



**Метод заполнения recievedDotsArray массива полученных ДОТов**
	Примечание: ObjCode -- элемент массива, объект Дота
	forcedDotsArray -- Принятый методом массив (переданный в персонажа) (Полностью аналогичен usableDotsArray)
	1. Взять нулевой элемент forcedDotsArray. Проверить наличие forcedDotsArray.code == recievedDots.code
		1. Если такой есть в recievedDotsArray, то:
			1. recievedDotsArray.ObjCode.DotDur = forcedDotsArray.ObjCode.DotDur
			2. recievedDotsArray.ObjCode.DotDmg +=1;
			3. recievedDotsArray.ObjCode.count +=1
			4. tick = 0
		2. Если нет, то:
			1. Добавить полностью объект в массив recievedDots, обогатив недостающими переменными с указанными значениями c помощью метода **конструктор объектов Полученных дотов**


**метод Проверки уворота**
	1. Взять значение характеристики evade персонажа.
	2. Сгенерировать случайное значение в диапазоне 0-1
	3. Проверить что, случайное значение < результата первого шага. Если да, вернуть true, иначе --  false


**Метод обработки воздействия полученных ДОТов**
	Условия: Постоянно обрабатывает массив объектов ДОТОв recievedDots, соответствующий по формату таковому у персонажа (forcedDotsArray).
	Примечание: ObjCode -- элемент массива, объект Дота
	Алгоритм:
		1. Запустить секундомер с шагом в 1с
		2. Проверить, что recievedDots не пустой. Если false, то ничего не делать. Иначе -- идти дальше по алгоритму.
		3. Перебором, для каждого элемента массива:
			1. По значению recievedDots.ObjCode.type определить тип воздействия ДОТа, на основании recievedDots.ObjCode.DotDmg -- временная переменная countedDotDmg: 
				1. если percent -- взять переменную персонажа maxHp, разделить на 100 , умножить на DotDmg, округлить до целого в бОльшую сторону. countedDotDmg = Math.Ceiling(this.actualHp* recievedDots.ObjCode.DotDmg/100)
				2. если fixed -- оставить значение DotDmg неизменным. countedDotDmg = DotDmg
				3. если baseDmgPercent -- оставить значение DotDmg неизменным countedDotDmg = DotDmg
			2. countedDotDmg -= buffResist, с округлением в большую сторону. Не меньше нуля.
			3. По значению recievedDots.ObjCode.affectedChar определить, на какую переменную будет воздействовать ДОТ: 
				1. Если Характеристика -- actualHP, то:
					1. **Метод получения урона**, в который передается countedDotDmg
					2. Проверить DotDur <= 1. Если да, удалить объект из массива. Иначе: DotDur -=1
				2. Иначе:
					3. Проверить, что recievedDots.ObjCode.tick < 1. если да, то: 
						1. Проверить, что характеристики одно из debuffResist или armor И (Значение характерстики - countedDotDmg) < 0. Тогда: 
							1. countedDotDmg = Значение характерстики
							2.  Изменить определенную выше характеристику: Значение характерстики - countedDotDmg.
							3. recievedDots.ObjCode.affectedDamage += countedDotDmg
						2. Иначе:
							1. Изменить определенную выше характеристику: Значение характерстики - countedDotDmg. 
							2. recievedDots.ObjCode.affectedDamage += countedDotDmg
			4. Если maxHP<= 0, вызвать **Метод смерти**
			5. recievedDots.ObjCode.tick ++
			6. Проверить DotDur <= 1. Если да, То взять характеристику, на которую оказывалось воздействие, прибавить к ней recievedDotsArray.ObjCode.affectedDamage, удалить объект из массива. Иначе: DotDur -=1



**Метод получения урона до брони**
Принимает значение damage
Вычесть из принятого  значения показатель брони персонажа. итоговое значение передать в **Метод получения урона**.

**Метод получения урона**
	1. Принимает значение урона.
	2. Округление урона до целочисленного в бОльшую сторону
	3. actualHP -= значение урона
	4. Проверка что actualHP > 0
		1.  Если нет -- вызвать **[[Персонажи|Метод Смерти]]**

**Метод смерти**
	1. Проверить, что isCanDie == true. Если да:
		1. isCanDie = false
		2. Удалить boxCollider объекта, который участвует в коллизии с врагами/патронами.
		3. Вызвать метод [[Выпадение Дропа]]
		4. вызвать метод наблюдателя **Увеличение счетчика убийств**, передав в него deathPrice
		5. Удалить объект и префаб персонажа.
		6. Добавить в [[Наблюдатель]]


Метод **Вампиризма**
	Округление до целочисленного в бОльшую сторону(actualHP += vampire)

**Метод нанесения урона ближнего боя**
	1. Вызвать анимацию ближнего боя.
	2. Вызвать метод **Проверки уворота** персонажа. Если вернут false, выйти из алгоритма
	3. Вызвать **Метод получения урона до брони** ([[Персонажи]]) Принимающего, передать в него meleeDamage
	4. Вызвать **Метод заполнения recievedDots массива полученных ДОТов** ([[Персонажи]]) Принимающего, передать в него массив usableDotsArray Дающего.
	5. Вызвать метод **Вампиризма** дающего ([[Персонажи]])

Наследники:
[[Игровой персонаж]]
[[Враги]]

**Метод изменения точек стрельбы**
 1. Преобразование входных данных принимает на вход `range = [a, b]` и count = n. (a, b,n = int)
	 1. Вычисляется шаг между точками: `step = (b - a) / max(1, n - 1)`
	 2. Для каждой из `n` точек вычисляется угол: `angle_i = a + step * i`
	3. Создается временный список `newCandidatePoints` с полученными углами        
2. **Объединение и сортировка точек:**
    1. Текущий список активных точек `CurrentPoints` объединяется со списком `newCandidatePoints`
    2. Полученный объединенный список сортируется по значению угла в порядке возрастания
3. **Разделение точек на группы по принадлежности к диапазонам:**
    1. Создается три группы точек:
        1. `pointsInsideNewRange` - точки из `CurrentPoints`, попадающие в диапазон `[a, b]`   
        2. `pointsOutsideNewRange` - точки из `CurrentPoints`, не попадающие в диапазон `[a, b]`    
        3. `newPoints` - точки из `newCandidatePoints`
4. **Обработка точек внутри нового диапазона:**
    1. Группа `pointsInsideNewRange` объединяется с группой `newPoints`
    2. Для объединенной группы выполняется разрешение конфликтов:
        1. Задается минимальный допустимый интервал между точками `minAngleInterval`
        2. Точки сортируются по углу
        3. Сливаются точки, находящиеся ближе чем `minAngleInterval`
    3. Выполняется равномерное распределение обработанных точек по диапазону `[a, b]`
5. **Формирование результирующего набора точек:**
    1. Создается финальный список точек, включающий:
        1. Точки из группы `pointsOutsideNewRange` (без изменений)
        2. Обработанные точки из объединенной группы `pointsInsideNewRange` + `newPoints`
    2. Финальный список сортируется по значению угла angle 
6. **Обновление состояния системы:**
    1. Полученный набор точек становится новым текущим состоянием `CurrentPoints`
    2. Для каждой точки вычисляется вектор направления: `direction = Quaternion.Euler(0, angle, 0) * Vector3.forward`
---

### Упрощенный пример

1. **Первоначальное состояние:**
	1. `CurrentPoints` содержит одну точку: `[0°]`
2. **Подбор первого предмета (`range = [-15, 15]`, `count = 2`):**
    1. Создание новых точек-кандидатов:
        1. `step = (15 - (-15)) / (2 - 1) = 30°`
        2. `angle_0 = -15 + 30 * 0 = -15°`
        3. `angle_1 = -15 + 30 * 1 = 15°`
        4. `newCandidatePoints = [-15°, 15°]`
    2. Объединение и сортировка точек:
        1. Объединенный список: `[0°, -15°, 15°]`
        2. После сортировки: `[-15°, 0°, 15°]`
    3. Разделение точек на группы:
        1. `pointsInsideNewRange`: `[0°]` (попадает в [-15, 15])
        2. `pointsOutsideNewRange`: `[]`
        3. `newPoints`: `[-15°, 15°]`
    4. Обработка точек внутри диапазона:
        1. Объединенная группа: `[-15°, 0°, 15°]`
        2. После разрешения конфликтов (minInterval=1°): `[-15°, 0°, 15°]`
        3. Равномерное распределение по [-15, 15]:
            1. Новый шаг: `(15 - (-15)) / (3 - 1) = 15°`
            2. Точки: `-15°`, `0°`, `15°`
    5. Финальный набор: `[-15°, 0°, 15°]`
3. **Подбор второго предмета (`range = [5, 30]`, `count = 4`):**
    1. Создание новых точек-кандидатов:
        1. `step = (30 - 5) / (4 - 1) ≈ 8.33°`
        2. `angle_0 = 5 + 8.33 * 0 = 5°`
        3. `angle_1 = 5 + 8.33 * 1 ≈ 13.33°`
        4. `angle_2 = 5 + 8.33 * 2 ≈ 21.67°`
        5. `angle_3 = 5 + 8.33 * 3 = 30°`
        6. `newCandidatePoints = [5°, 13.33°, 21.67°, 30°]`
    2. Объединение и сортировка:
        1. Объединенный список: `[-15°, 0°, 15°, 5°, 13.33°, 21.67°, 30°]`
        2. После сортировки: `[-15°, 0°, 5°, 13.33°, 15°, 21.67°, 30°]`
    3. Разделение точек на группы:
        1. `pointsInsideNewRange`: `[5°, 13.33°, 15°]` (попадают в [5, 30])
        2. `pointsOutsideNewRange`: `[-15°, 0°]` (не попадают в [5, 30])
        3. `newPoints`: `[5°, 13.33°, 21.67°, 30°]
    4. Обработка точек внутри диапазона:
        1. Объединенная группа: `[5°, 13.33°, 15°, 5°, 13.33°, 21.67°, 30°]`
        2. После удаления дубликатов: `[5°, 13.33°, 15°, 21.67°, 30°]`
        3. После разрешения конфликтов: `[5°, 13.33°, 15°, 21.67°, 30°]`
        4. Равномерное распределение по [5, 30]:
            1. Новый шаг: `(30 - 5) / (5 - 1) = 6.25°`
            2. Точки: `5°`, `11.25°`, `17.5°`, `23.75°`, `30°`
    5. Финальный набор:
        1. Точки вне диапазона: `[-15°, 0°]` (без изменений)
        2. Точки внутри диапазона: `[5°, 11.25°, 17.5°, 23.75°, 30°]`
        3. Итоговый отсортированный список: `[-15°, 0°, 5°, 11.25°, 17.5°, 23.75°, 30°]`