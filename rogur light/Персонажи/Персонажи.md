
1. По контуру модельки идет хитбокс, выступающий генератором событий [[Коллизия с уроном и Дотами]]
2. Переменная isEnemy: bool, отвечающая за то, является ли объект врагом или связанным с врагом.
3. Обладает тегом. тег заполняется в зависимости, [[Игровой персонаж|игрок]] или [[Враги|враг]].
4. Находится в слое [[Слои|слое]] enemy
5. Осуществляет поворот со скоростью rotateSpeed
Переменные:
1. Все характеристики берутся из файла [[Улучшаемые характеристики]] (по условию type == true) как отдельные переменные.
2. actualHP -- int -- переменная актуального хп
3. Добавляется массив recievedDots -- object array -- массив полученных (как цель воздействия) ДОТов. 
4.   usableDotsArray -- Массив объектов Имеющихся ДОТов
5. shootingModifierFirstArray, shootingModifierSecondArray, shootingModifierThirdArray -- массивы String, содержащие в себе code модификаторов стрельбы.
6. whileFlyModifiersArray, onCollisionModifiersArray, whenDestroyModifiersArray -- массивы String кодов модификаторов полета пули.
7. isCanDie
8. точки стрельбы shotPointsArray = new List shotPoint
	    new ShotPoint { angle = 0f, dirction = vector2, isActive = true } 
   
**Методы:**
9. Стрельба осуществляется через **метод Стрельбы
10. Обладает методом [[Генерация выстрела| Генерации выстрела]]
11. Обладает методом [[Коллизия с уроном и Дотами]]
12. Обладает **Методом смерти**, переопределяемым для [[Игровой персонаж]]
13. метод [[Выпадение Дропа]]
14. **конструктор объектов наносимых дотов**
15. **конструктор объектов Полученных дотов**
16. **Метод добавления в массив ДОТов usableDotsArray**
17. **Метод заполнения recievedDots массива полученных ДОТов**
18. **метод Проверки уворота**
19. **Метод получения урона до брони**
20. **Метод получения урона**
21. **Метод обработки воздействия полученных ДОТов**
22. **Метод применения модификаторов стрельбы**
23. **Метод ближнего боя**
24. 1
25. Метод **Вампиризма**
26. **Метод нанесения урона ближнего боя**
27. **Метод изменения точек стрельбы**
28. Метод деактивации точек стрельбы
29. Метод активации точек стрельбы





Создать **конструктор объектов Полученных дотов**: 
	Примечание: Получает значения
	 [[Улучшаемые характеристики]] = improvableCharacteristicDictionary
	[[Справочник ДОТов]] = dotsDictionary
	Маппинг: improvableCharacteristicDictionary.code = dotsDictionary.code 
	1. Объект содержит: code, DotDmg, DotDur, type, affectedChar, count, tick
	2. Объект = значение, переданное в метод, в случае, если их не хватает, обогатить из справочников по маппингу:
		1. code = improvableCharacteristicDictionary.code
		2. affectedChar = dotsDictionary.affectedChar
		3. type = dotsDictionary.type,
		4. DotDmg =  dotsDictionary.baseDotDmg
		5. DotDur = dotsDictionary.baseDotDur
		6. affectedDamage = 0
		7. count = 1
		8. tick = 0;



**Метод Стрельбы**
	Принимает значения: 
	Запрашивает значение дамага, массива дотов, скорости атаки
	Стрелять можно если от последнего выстрела прошло 1/скорость атаки тиков.
		Если проверка пройдена, вызвать метод **Метод применения модификаторов стрельбы**
	


**Метод применения модификаторов стрельбы**
Принимает значения: 
 1. Взять значение точек стрельбы перебором по массиву shotPointsArray для каждого объекта shotPoint c isActive == true:
 2. Для каждой точки Взять значение shootingModifierSecondArray для каждого:
	 2. по code взять значение из [[Справочник модификаторов стрельбы]], определить type:
		 4. Если base, то Совершать только один выстрел
		 5. Если burst -- сформировать очередь из count количества выстрелов, с задержкой между ними 1/(count * atkSpeed) секунд. *Кулдаун будет отсчитываться от последнего выстрела в очереди*
 3. Для каждого выстрела: 
	 1. по code взять значение из [[Справочник модификаторов стрельбы]], определить type(Да, сейчас тут нет разницы, но я подозреваю, что она может быть, правда пока ХЭЗЭ какая):
		 1. Если base, то Создать один патрон [[Генерация выстрела]], Передав в него spread = (1 - accuracy из справочника) * 10, dmg, usableDotsArray, critChance, bulletflySpeed, bulletTimeAlive, whileFlyModifiersArray, onCollisionModifiersArray, whenDestroyModifiersArray, gameobjectId стреляющего
		 2. Если buckshot, то создать count патронов ([[Генерация выстрела]]), передавая в каждый spread = (1 - accuracy из справочника) * 10, dmg, usableDotsArray, critChance, bulletflySpeed, bulletTimeAlive, whileFlyModifiersArray, onCollisionModifiersArray, whenDestroyModifiersArray, gameobjectId, shotPointsArray.shotPoint.direction




**Метод ближнего боя**
Срабатывает при коллизии. Только в слоях, где находится игрок и Враги. 
1. Проверить тег того, с кем коллизия. Тег должен быть противоположен в дихотомии "Player" - "Enemy" И не содержать "Bullet". Если условия выполнены:
	1. **Метод нанесения урона ближнего боя**
	2. Ждать 1/atkSpeed, не давая вызвать **Метод нанесения урона ближнего боя**



**Метод добавления в массив ДОТов usableDotsArray**
	Принимает объект ДОТа
		1. Добавить Объект ДОТа в массив usableDotsArray



**Метод заполнения recievedDotsArray массива полученных ДОТов**
	Примечание: ObjCode -- элемент массива, объект Дота
	forcedDotsArray -- Принятый методом массив (переданный в персонажа) (Полностью аналогичен usableDotsArray)
	1. Взять нулевой элемент forcedDotsArray. Проверить наличие forcedDotsArray.code == recievedDots.code
		1. Если такой есть в recievedDotsArray, то:
			1. recievedDotsArray.ObjCode.DotDur = forcedDotsArray.ObjCode.DotDur
			2. recievedDotsArray.ObjCode.DotDmg +=1;
			3. recievedDotsArray.ObjCode.count +=1
			4. tick = 0
		2. Если нет, то:
			1. Добавить полностью объект в массив recievedDots, обогатив недостающими переменными с указанными значениями c помощью метода **конструктор объектов Полученных дотов**


**метод Проверки уворота**
	1. Взять значение характеристики evade персонажа.
	2. Сгенерировать случайное значение в диапазоне 0-1
	3. Проверить что, случайное значение < результата первого шага. Если да, вернуть true, иначе --  false


**Метод обработки воздействия полученных ДОТов**
	Условия: Постоянно обрабатывает массив объектов ДОТОв recievedDots, соответствующий по формату таковому у персонажа (forcedDotsArray).
	Примечание: ObjCode -- элемент массива, объект Дота
	Алгоритм:
		1. Запустить секундомер с шагом в 1с
		2. Проверить, что recievedDots не пустой. Если false, то ничего не делать. Иначе -- идти дальше по алгоритму.
		3. Перебором, для каждого элемента массива:
			1. По значению recievedDots.ObjCode.type определить тип воздействия ДОТа, на основании recievedDots.ObjCode.DotDmg -- временная переменная countedDotDmg: 
				1. если percent -- взять переменную персонажа maxHp, разделить на 100 , умножить на DotDmg, округлить до целого в бОльшую сторону. countedDotDmg = Math.Ceiling(this.actualHp* recievedDots.ObjCode.DotDmg/100)
				2. если fixed -- оставить значение DotDmg неизменным. countedDotDmg = DotDmg
				3. если baseDmgPercent -- оставить значение DotDmg неизменным countedDotDmg = DotDmg
			2. countedDotDmg -= buffResist, с округлением в большую сторону. Не меньше нуля.
			3. По значению recievedDots.ObjCode.affectedChar определить, на какую переменную будет воздействовать ДОТ: 
				1. Если Характеристика -- actualHP, то:
					1. **Метод получения урона**, в который передается countedDotDmg
					2. Проверить DotDur <= 1. Если да, удалить объект из массива. Иначе: DotDur -=1
				2. Иначе:
					3. Проверить, что recievedDots.ObjCode.tick < 1. если да, то: 
						1. Проверить, что характеристики одно из debuffResist или armor И (Значение характерстики - countedDotDmg) < 0. Тогда: 
							1. countedDotDmg = Значение характерстики
							2.  Изменить определенную выше характеристику: Значение характерстики - countedDotDmg.
							3. recievedDots.ObjCode.affectedDamage += countedDotDmg
						2. Иначе:
							1. Изменить определенную выше характеристику: Значение характерстики - countedDotDmg. 
							2. recievedDots.ObjCode.affectedDamage += countedDotDmg
			4. Если maxHP<= 0, вызвать **Метод смерти**
			5. recievedDots.ObjCode.tick ++
			6. Проверить DotDur <= 1. Если да, То взять характеристику, на которую оказывалось воздействие, прибавить к ней recievedDotsArray.ObjCode.affectedDamage, удалить объект из массива. Иначе: DotDur -=1



**Метод получения урона до брони**
Принимает значение damage
Вычесть из принятого  значения показатель брони персонажа. итоговое значение передать в **Метод получения урона**.

**Метод получения урона**
	1. Принимает значение урона.
	2. Округление урона до целочисленного в бОльшую сторону
	3. actualHP -= значение урона
	4. Проверка что actualHP > 0
		1.  Если нет -- вызвать **[[Персонажи|Метод Смерти]]**

**Метод смерти**
	1. Проверить, что isCanDie == true. Если да:
		1. isCanDie = false
		2. Удалить boxCollider объекта, который участвует в коллизии с врагами/патронами.
		3. Вызвать метод [[Выпадение Дропа]]
		4. вызвать метод наблюдателя **Увеличение счетчика убийств**, передав в него deathPrice
		5. Удалить объект и префаб персонажа.
		6. Добавить в [[Наблюдатель]]


Метод **Вампиризма**
	Округление до целочисленного в бОльшую сторону(actualHP += vampire)

**Метод нанесения урона ближнего боя**
	1. Вызвать анимацию ближнего боя.
	2. Вызвать метод **Проверки уворота** персонажа. Если вернут false, выйти из алгоритма
	3. Вызвать **Метод получения урона до брони** ([[Персонажи]]) Принимающего, передать в него meleeDamage
	4. Вызвать **Метод заполнения recievedDots массива полученных ДОТов** ([[Персонажи]]) Принимающего, передать в него массив usableDotsArray Дающего.
	5. Вызвать метод **Вампиризма** дающего ([[Персонажи]])

**Метод изменения точек стрельбы**
	 Преобразование входных данных принимает на вход `range = [a, b]` и count = n. (a, b,n = int)
1. **Разделение точек по принадлежности к новому диапазону:**
    1. перебрать имеющийся массив shotPointsArray: Записать в PointsInside все angle точек, для которых angle >= a, angle <= b. Удалить их из массива shotPointsArray
        1. `PointsInside` - точки из объединенного массива, попадающие в диапазон `[A, B]`
2. **Равномерное распределение точек внутри диапазона:**
    1. Для группы `PointsInside` выполняется перераспределение:
        1. Вычисляется количество точек в группе: `M = len(PointsInside) + count` 
        2. Определяется новый шаг распределения: `uniform_step = (b - a) / max(1, M - 1)`
        3. Для каждой позиции `j` от `0` до `M-1` вычисляется новый угол: `new_angle_j = a + uniform_step * j`
3. **Формирование итогового массива точек:**
    1. Создается результирующий массив из точек групп:
        1. Перераспределенные точки из `PointsInside`
    2. Массив сортируется по значению угла
4. **Подготовка данных для стрельбы:**
    1. Для каждой точки итогового массива вычисляются и сохраняются:
        1. angle = Угол в градусах
        2. direction = Нормализованный вектор направления получается следующим образом:
	        1. angle_rad = angle * Mathf.Deg2Rad
	        2. x = Mathf.Cos(angle_rad)
	        3. y = Mathf.Sin(angle_rad)
	        4. direction = new Vector2(x, y)
        3. isActive = true -- Флаг активности
### Пример выполнения алгоритма:
**Исходное состояние:**
- `CurrentAngles`: 10 точек в диапазоне [0, 30]
- Углы: `[0°, 3.33°, 6.67°, 10°, 13.33°, 16.67°, 20°, 23.33°, 26.67°, 30°]`
**Новый предмет:** `range = [10, 20]`, `count = 5`

1. **Разделение точек:**
    1. `PointsInside`: `[10°, 13.33°, 16.67°, 20°]`
2. **Равномерное распределение:**
    1. `M = 4 + 5 = 9`, `uniform_step = (20 - 10) / (9 - 1) = 1.25°`
    2. Новые углы: `[10°, 11.25°, 12.5°, 13.75°, 15°, 16.25°, 17.5°, 18.75°, 20°]`
3. **Итоговый массив:**
    1. `PointsInside`: `[10°, 11.25°, 12.5°, 13.75°, 15°, 16.25°, 17.5°, 18.75°, 20°]`
    2. Результат: `[0°, 3.33°, 6.67°, 10°, 11.25°, 12.5°, 13.75°, 15°, 16.25°, 17.5°, 18.75°, 20°, 23.33°, 26.67°, 30°]`
    3. Проверка: 15 точек = 10 + 5 ✓

**Метод деактивации точек стрельбы**
Принимает n (int)
1. Взять по очереди все значения shotPointsArray, для каждого n-го проставить isActive = false

**метод активации точек стрельбы**
1. Взять по очереди все значения shotPointsArray, для каждого проставить isActive = true

Наследники:
[[Игровой персонаж]]
[[Враги]]
