Объект стрельбы.
Умеет летать, имеет хитбокс, которым стукает. Содежржит тег, соответствующий тегу [[Персонажи|стреляющего]] +"Bullet"  
Переменные:
public float timeDestroy = bulletTimeAlive: int; -- время до уничтиожения объекта
public float speed = bulletflySpeed: int; -- скорость полета пули
private Rigidbody2D rb; -- какая-то техническая хуита
public Array dotsArray; -- Массив дотов, переданный в патрон создавшим патрон [[Персонажи]]
public int damage = dmg; -- урон, который нанесет патрон при попадании
public Vector2 aimCoords; -- вектор, направление полёта патрона

whileFlyModifiersArray, onCollisionModifiersArray, whenDestroyModifiersArray -- массивы кодов модификаторов полета.
whileFlyModifiersBulletArray -- массив объектов формы полета [[Справочник модификаторов патронов]]
whileFlyModifiersEffectBulletArray -- массив объектов эффекта полета [[Справочник модификаторов патронов]]
onCollisionModifiersBulletArray -- массив объектов эффекта коллизии [[Справочник модификаторов патронов]]
whenDestroyModifiersBulletArray -- массив объектов эффекта уничтожения [[Справочник модификаторов патронов]]




**Метод старта**
   **Метод создания массива модификаторов полета**
   **Метод создания массива модификаторов коллизии**
   **Метод создания массива модификаторов уничтожения**
   
   
**Метод полета** (Update)
Постоянно проверять, что bulletTimeAlive >0. Если нет, удалить объект осколка.
Постоянно уменьшать bulletTimeAlive.
Вызвать **Метод определения формы полёта**
Совершить смещение по результирующему вектору в зависимости от скорости передвижения.
**Метод применения эффекта полёта**



**Метод Коллизии**
	1. Проверить, что коллизия происходит не с патроном и не осколком. Если да, продолжить алгоритм.
	2. Сверить теги: от тега Патрона отрезается "Bullet", остаток должен быть противоположен тегу Принимающего (того, с кем провзаимодействовал патрон). Если да:
		1. Вызвать **Метод нанесения урона**.
		2. Проверить в onCollisionModifiersBulletArray наличие записи с enemyRicoshet И для неё value > 0 Если нет:
			1. Вызвать **метод удаления патрона**
			2. Прекратить выполнение алгоритма. 
		3. Если да:
			1. для объекта onCollisionModifiersBulletArray value --
			2. Вызвать метод **Метод поиска ближайшей цели**.
			3. Перенаправить патрон по вектору к переданным координатам.
	3. Если столкновение с препятствием типа brick:
		1. Проверить в onCollisionModifiersBulletArray наличие записи с obstRicoshet И для неё value > 0 Если нет:
			1. Вызвать **метод удаления патрона**
			2. Прекратить выполнение алгоритма. 
		2. Если да:
			1. для объекта onCollisionModifiersBulletArray value --
			2. Вызвать метод **Метод рикошета**
			3. Перенаправить патрон по сформированному вектору .
	4. В остальных случаях -- просто лететь дальше, коллизии нет.



**Метод удаления патрона**
Проверить whenDestroyModifiersBulletArray на пустоту. Если да -- удалить объект. Если нет:
	1. Проверить наличие в массиве записи с type = blast. Если да, то:
		1.  Вызвать **Метод определения целей по тегу**, передав в него ampl. Получить массив objectId
		2. Для каждого из них вызвать **Метод получения урона до брони** [[Персонажи]] , передав в него value *(Из объекта модификатора)* процентов от dmg патрона, округленное до целого математичски (dmg * value / 100)
	2. Проверить наличие в массиве записи с type = splinters. Если да, то:
		1. Вызвать **Метод рикошета**, записать как ricoshetVector
		2. Далее, циклично freq раз:
			1. Рассчитать splinterDmg = dmg * value/ 100
			2. Вызвать метод [[Генерация осколков]] передав в него: 
				1. ricoshetVector
				2. splinterFlySpeed = bulletflySpeed * 2
				3. splinterTimeAlive = bulletTimeAlive / 2
				4. splinterDmg
				5. ampl
				6. тег






**Метод создания массива модификаторов полета**
Перебором по массиву whileFlyModifiersArray с запросами по Элемент Массива == code [[Справочник модификаторов патронов]] создать объекты соответствующих Модификаторов.
	whileFlyModifiersBulletArray -- заполняется значениями с type == "homing" и/или "sinusoidal" 
	whileFlyModifiersEffectBulletArray  -- заполняется значениями с type == "aura" и/или "electricity" 
Очистить whileFlyModifiersArray

**Метод создания массива модификаторов коллизии**
1. Перебором по массиву onCollisionModifiersArray с запросами по Элемент Массива == code [[Справочник модификаторов патронов]] создать объекты соответствующих Модификаторов в массив onCollisionModifiersBulletArray

**Метод создания массива модификаторов уничтожения**
1. Перебором по массиву whenDestroyModifiersArray с запросами по Элемент Массива == code [[Справочник модификаторов патронов]] создать объекты соответствующих Модификаторов в массив whenDestroyModifiersBulletArray



**Метод нанесения урона** -- Вызывается при коллизии (Описано в [[Коллизия с уроном и Дотами]]): 
	1. Вызвать метод **Проверки уворота** персонажа. Если вернут false, выйти из алгоритма
	2. Вызвать **Метод получения урона до брони** ([[Персонажи]]) Принимающего, передать в него damage патрона
	3. Вызвать **Метод заполнения recievedDots массива полученных ДОТов** ([[Персонажи]]) Принимающего, передать в него массив dotsArray из переменных патрона.




**Метод определения формы полёта**
1. Взять массив whileFlyModifiersBulletArray. 
2. Искать в нём объект с type = homing
	1. Если да, вызвать **Метод самонаведения патрона**, передав в него текущий вектор движения, найденный объект  
3. Искать в нём объект с type = sinusoidal
	1. Если да:  Вызвать **Метод синусоидального движения**, передав в него 
4. Провести смещение патрона по результирующему вектору 
	   


**Метод самонаведения патрона**
Принимает изначальное направление движения, code объекта [[Справочник модификаторов патронов]] с type = "homing"
1. Вызвать **Метод поиска ближайшей цели**, Если цель найдена:
	1. записать результат в target
	2. Сформировать вектор направления к ближайшей цели, записать в targetDirection
	3. Сформировать вектор плавного изменения:
	   СurrentDirection = Vector2.Lerp(currentDirection, targetDirection, value (взять из объекта whileFlyModifiersBulletArray) * Time.deltaTime).normalized; -- Вообще, не факт, что это стоит использовать. Возможно, стоит подобрать иной аналог и з предполагаемых юнити или сделать чисто математический ( https://habr.com/ru/articles/318046/   ,   https://kostegs.name/how-to-use-lerp-in-unity/  )
	4. Вернуть результирующий вектор
2. Если цель не найдена -- вернуть изначальный вектор движения


**Метод синусоидального движения**
Принимает 
1. Определить перпендикулярный изначально заданному вектор: 
		direction.Normalize(); (direction -- изначальное направление). 
		Получаем перпендикулярное направление perpendicularDirection = new Vector2(-direction.y, direction.x);
2. Определить значение синуса: float sinValue = Mathf.Sin(Time.time * freq) * ampl * value ; *(freq, ampl, value) -- взять из объекта whileFlyModifiersBulletArray
3. Сформировать результиующий вектор по принципу (direction * bulletflySpeed + perpendicularDirection * sinValue) * Time.deltaTime;



**Метод применения эффекта полёта**
1. проверить, что массив whileFlyModifiersEffectBulletArray не пустой. Если да, то:
	1. проверить наличие записи с type == "aura". Если да, то **Метод аурного эффекта**, передать в него объект массива whileFlyModifiersEffectBulletArray
	2. проверить наличие записи с type == "electricity". Если да, то **Метод  электрического эффекта




**Метод аурного эффекта**
1.  Вызвать **Метод определения целей по тегу** в ampl *(Из объекта модификатора)*
2. Для каждого из них вызвать метод получения урона [[Персонажи]] (*Обратите внимание, не до брони*), передав в него value *(Из объекта модификатора)* процентов от dmg патрона, округленное до целого математичски (dmg * value / 100)
3. ждать до следующего воздействия 1/freq *(Из объекта модификатора)* секунд

**Метод электрического эффекта**
1. Вызвать **Метод поиска ближайших целей по количеству**, передав в него ampl *(Из объекта модификатора)*. Для каждой из них:
	1. Сгенерировать анимацию /картинку желтой тонкой линии, соединяющей потрон и объект-цель воздействия
	2. вызвать метод получения урона [[Персонажи]], передав в него value *(Из объекта модификатора)* процентов от dmg патрона, округленное до целого метматичски (dmg * value / 100)
2. Ждать до следующего воздействия 1/freq *(Из объекта модификатора)* секунд
   
   


**Метод поиска ближайшей цели**
	1. Вызвать **Метод определения целей по тегу**, передав в него 10f
	2. Вычислить координаты ближайшего объекта, Вернуть их. 

**Метод поиска ближайших целей по количеству**
Принимает количество = valueTargets
	1. Вызвать **Метод определения целей по тегу**, передав в него 10f
	2. Вернуть массив id всех valueTargets ближайших уникальных объектов. 

**Метод определения целей по тегу**
Принимает расстояние distance. 
	В зоне, радиусом в distance найти все объекты, не являющиеся патронами, с тегом Enemy, если тег патрона -- Player, и наоборот.
	Вернуть массив идентификаторов целей.

**Метод рикошета**
1. Взять имеющийся вектор.
2. Найти направление отскока как наименьший из углов пересечения вектора с плоскостью коллизии. Простроить вектор по этому направлению.