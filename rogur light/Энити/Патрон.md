Объект стрельбы.
Умеет летать, имеет хитбокс, которым стукает. Содежржит тег, соответствующий тегу [[Персонажи|стреляющего]] +"Bullet"  
Переменные:
public float timeDestroy = bulletTimeAlive: int; -- время до уничтиожения объекта
public float speed = bulletflySpeed: int; -- скорость полета пули
private Rigidbody2D rb; -- какая-то техническая хуита
public Array dotsArray; -- Массив дотов, переданный в патрон создавшим патрон [[Персонажи]]
public int damage; -- урон, который нанесет патрон при попадании
public Vector2 aimCoords; -- вектор, направление полёта патрона

whileFlyModifiersArray, onCollisionModifiersArray, whenDestroyModifiersArray -- массивы кодов модификаторов полета.

**Метод создания массива ДОТов dotsArray** -- для заполнения dotsArray
	Принимает массив объектов ДОТа
	1. dotsArray = массив объектов ДОТа


**Нанесение Урона**.
	Принимает урон.
	1. damage = урон


**Метод нанесения урона** -- Вызывается при коллизии (Описано в [[Коллизия с уроном и Дотами]]): 
	1. Сверить теги: от тега Патрона отрезается "Bullet", остаток должен быть противоположен тегу Принимающего (того, с кем провозаимодействовал патрон). 
	2. Вызвать метод **Проверки уворота** персонажа. Если вернут false, выйти из алгоритма
	3. Вызвать **Метод получения урона до брони** ([[Персонажи]]) Принимающего, передать в него damage патрона
	4. Вызвать **Метод заполнения recievedDots массива полученных ДОТов** ([[Персонажи]]) Принимающего, передать в него массив dotsArray из переменных патрона.
   
   
   **Метод полета**


**Метод определения формы полёта**
1. Взять массив whileFlyModifiersArray. 
2. Искать в нём code, соответствующий записи в [[Справочник модификаторов патронов]] с type = homing
3. Искать в нём code, соответствующий записи в [[Справочник модификаторов патронов]] с type = sinusoidal
4. Если да:
	1. Определить перпендикулярный изначально заданному вектор: 
		direction.Normalize(); (direction -- изначальное направление)
        // Получаем перпендикулярное направление
        perpendicularDirection = new Vector2(-direction.y, direction.x);
	2. Определить значение синуса: float sinValue = Mathf.Sin(Time.time * freq) * ampl * value ; *(freq, ampl, value) -- справочные значения
	3. Использовать для движения transform.position += (Vector3)(direction * bulletflySpeed + perpendicularDirection * sinValue) * Time.deltaTime;